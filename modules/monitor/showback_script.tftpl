const IS_LOCAL_ENV = typeof $env === "undefined" || $env === null;

// Comment the following lines to log debug messages
console.log = function() {}
console.debug = function() {}

/**
 * For local development
 */
if (IS_LOCAL_ENV) {
  global._isApiTest = true;
  require("../lib/simulator");
}

const region = '${tf_new_relic_region}';  // 'US' | 'EU'
if (region === 'US') {
  var nerdGraphEndpoint = 'https://api.newrelic.com/graphql';
  var eventApiEndpoint = 'https://insights-collector.newrelic.com';
  var metricApiEndpoint = 'https://metric-api.newrelic.com/metric/v1';
} else if (region === 'EU') {
  var nerdGraphEndpoint = 'https://api.eu.newrelic.com/graphql';
  var eventApiEndpoint = 'https://insights-collector.eu01.nr-data.net';
  var metricApiEndpoint = 'https://metric-api.eu.newrelic.com/metric/v1';
} else { // default to US
  var nerdGraphEndpoint = 'https://api.newrelic.com/graphql';
  var eventApiEndpoint = 'https://insights-collector.newrelic.com';
  var metricApiEndpoint = 'https://metric-api.newrelic.com/metric/v1';
}

// Account details, during local development
if (IS_LOCAL_ENV) {
  const credentialsConfig = require('./credentials-config.json');
  var $secure = new Object();
  $secure.SHOWBACK_INSERT_LICENSE_API_KEY = credentialsConfig.ingestLicenseApiKey;
  $secure.SHOWBACK_QUERY_USER_API_KEY = credentialsConfig.userApiKey;
}

// Event constants
const ACCOUNT_USERS_DATA_TYPE_NAME = "Showback_AccountUsers";
const UNIQUE_USERS_DATA_TYPE_NAME = "Showback_UniqueUsers";
const DEPARTMENT_ATTRIBUTE_NAME = "departmentName";
const DEPARTMENT_UNASSIGNED = "Unassigned"
const FULL_USER_COUNT_ATTRIBUTE_NAME = "fullUserCount";
const CORE_USER_COUNT_ATTRIBUTE_NAME = "coreUserCount";
const BASIC_USER_COUNT_ATTRIBUTE_NAME = "basicUserCount";
const TOTAL_USER_COUNT_ATTRIBUTE_NAME = "totalUserCount";
const SHOWBACK_REPORTING_INSERT_ACCOUNT_ID = ${tf_showback_insert_account_id};

const CHUNK_SIZE = 100;
const GQL_API_CHUNK_SIZE = 25;
const MAX_RETRIES = 3;

const DEFAULT_DEPT_TIER = 1;


/**
 * Process showback (https://en.wikipedia.org/wiki/IT_chargeback_and_showback) for an organization, as associated with the supplied user api key. 
 * @returns {Promise} indicating successful completion of the function.
 */
async function processShowback() {
  // Get org accounts
  let managedAccountsArray = await getOrgAccounts();
  console.log('processShowback(): managedAccountsArray:', managedAccountsArray);

  // Build a map of account ids to accounts
  let accountIdToAccountMap = new Map();
  for (const account of managedAccountsArray) {
    accountIdToAccountMap.set(account.id, account);
  }

  // Get an array of auth domains for the organization
  let authDomainsArray = await getAuthDomainsArray();
  console.log('processShowback(): authDomainsArray:', authDomainsArray);

  // Get a map of auth domains to their groups
  let authDomainToGroupsMap = await getAuthDomainToGroupsMap(authDomainsArray);
  console.log('processShowback(): authDomainToGroupsMap:', authDomainToGroupsMap);

  // Build a map of group ids to group names
  let groupIdToGroupNameMap = new Map();
  for (const authDomain of authDomainToGroupsMap) {
    for (const group of authDomain[1]) {
      groupIdToGroupNameMap.set(group.id, group.displayName);
    }
  }

  // Get a map of groups by id to their roles
  let groupIdToRolesMap = await getGroupIdToRolesMap(authDomainToGroupsMap); // Contains group:account relationships 
  console.log('processShowback(): groupToRolesMap:', groupIdToRolesMap);

  // Check for groups with no roles, roles with no account, and roles that reference a canceled account
  for (const [groupId, roles] of groupIdToRolesMap) {
    let groupName = groupIdToGroupNameMap.get(groupId);
    if (roles.length == 0) console.warn('processShowback(): group ' + groupName + ' has no roles');
    for (const role of roles) {
      let account = accountIdToAccountMap.get(role.accountId);
      if (!account) {
        console.warn('processShowback(): group ' + groupName + ' has a role ' + role.displayName + ' with no account');
      } else if (account.isCanceled) {
        console.warn('processShowback(): group ' + groupName + ' has a role ' + role.displayName + ' that references a canceled account ' + account.id + ', ' + account.name);
      }
    }
  }

  // Get a map of groups by id to their group and users
  let groupIdToGroupAndUsersMap = await getGroupIdToGroupAndUsersMap(authDomainsArray);  // Contains group:users relationships
  console.log('processShowback(): getGroupIdToGroupAndUsersMap:', groupIdToGroupAndUsersMap);

  // Build a map of users (by email) to their user details and groups
  let emailToUserAndGroupsMap = buildEmailToUserAndGroupsMap(groupIdToGroupAndUsersMap);  // Contains user:groups relationships
  console.log('processShowback(): buildEmailToUserAndGroupsMap:', emailToUserAndGroupsMap);

  // Enrich, and consolidate (by case email insensitive) users map
  let { enrichedEmailToUserAndGroupsMap, consolidatedEmailToUserAndGroupsMap } = await enrichEmailToUserAndGroupsMap(authDomainsArray, emailToUserAndGroupsMap);
  console.log('processShowback(): enrichedEmailToUserAndGroupsMap:', enrichedEmailToUserAndGroupsMap, 'consolidatedEmailToUserAndGroupsMap:', consolidatedEmailToUserAndGroupsMap);

  // Build a map of users by email to their accounts, and a case insensitive map too
  let { emailToAccountSetMap, consolidatedEmailToAccountSetMap } = buildEmailToAccountsMap(enrichedEmailToUserAndGroupsMap, groupIdToRolesMap, accountIdToAccountMap);

  // Get department to tier map
  let departmentToTierMap = getDepartmentToTierMap();

  // Build a map of departments to their user type counts, and also return an updated email to user map with the departments added
  let { departmentToUserTypeCountsMap, emailToDepartmentSetMap } = buildDepartmentToUserTypeCountsMap(consolidatedEmailToAccountSetMap, consolidatedEmailToUserAndGroupsMap, accountIdToAccountMap);

  // Build a map of accounts, by id, to their users
  let accountIdToUsersMap = buildAccountToUsersMap(enrichedEmailToUserAndGroupsMap, groupIdToRolesMap);

  // Get the current time
  const currentTimestamp = new Date().getTime();  // The current time in milliseconds since the Epoch

  // Create showback.department and aggregated showback.organization metrics in NRDB
  postDepartmentShowback(departmentToUserTypeCountsMap, departmentToTierMap, currentTimestamp);

  // Create Showback_AccountUsers in NRDB
  let accountUsersArray = postAccountUsers(enrichedEmailToUserAndGroupsMap, groupIdToRolesMap, accountIdToAccountMap);

  // Create showback.account metrics in NRDB
  postAccounts(accountIdToUsersMap, accountIdToAccountMap, currentTimestamp);

  // Build a UniqueUsersArray
  let uniqueUsersArray = buildUniqueUsersArray(enrichedEmailToUserAndGroupsMap, emailToDepartmentSetMap);

  // Create Showback_UniqueUsers in NRDB
  postUniqueUsers(uniqueUsersArray);

  return "Success";
}


/**
 * Gets a map of department tier to a map of the count of department/cost-center/business-unit to which user on the account with Full platform access or Core should be assigned.
 * @param {*} account an account to be mapped to a department. 
 * @returns a map of department tier to a map of the count of department/cost-center/business-unit.
 */
function getDepartmentMapping(account) {
  let departments = ${jsonencode(tf_showback_config)};

  let tierToDeptSetMap = new Map();
  for (const department of departments) {
    let deptSet = new Set();
    for (const accounts_in of department.accounts_in) {
      if (accounts_in.includes(account.name)) {
        deptSet.add(department.department_name);
      }
    }
    for (const accounts_regex of department.accounts_regex) {
      if (new RegExp(accounts_regex).test(account.name)) {
        deptSet.add(department.department_name);
      }
    }
    if (tierToDeptSetMap.has(department.tier)) {
      let existingDeptSet = tierToDeptSetMap.get(department.tier);
      let mergedSet = new Set([...existingDeptSet, ...deptSet])
      tierToDeptSetMap.set(department.tier, mergedSet);
    } else {
      tierToDeptSetMap.set(department.tier, deptSet);
    }
  }

  for (const [tier, deptSetMap] of tierToDeptSetMap) {
    if (deptSetMap.size == 0) {
      console.error("getDepartment(): The department of account", account.name, 'is unassigned in tier', tier);
      tierToDeptSetMap.set(tier, deptSetMap.add(DEPARTMENT_UNASSIGNED));
    }
  }

  return tierToDeptSetMap;;
}


/**
 * Gets the department to tier map.
 * @returns the department to tier map.
 */
function getDepartmentToTierMap() {
  return new Map([
    %{~ for index_department, department in tf_showback_config ~}
    [ "${department.department_name}", ${department.tier} ]%{~ if index_department <= length(department) },%{~ endif }
    %{~ endfor ~}
  ]);
}


/**
 * Build a UniqueUsersArray.
 * @param {*} emailToUserAndGroupsMap a map of users (by email) to their user details and groups.
 * @param {*} emailToDepartmentSetMap a map of user email to their departments.
 * @returns a UniqueUsersArray.
 */
function buildUniqueUsersArray(emailToUserAndGroupsMap, emailToDepartmentSetMap) {
  let uniqueUsersArray = [];
  for (const [email, user] of emailToUserAndGroupsMap) {
    let lastAccess = new Date(user.lastActive).getTime();
    let userTierName;
    if (user.type.displayName == 'Full platform') {
      userTierName = 'FSO';
    } else if (user.type.displayName == 'Basic') {
      userTierName = 'Basic';
    } else {
      userTierName = 'Core';
    }
    let departmentSet = null;
    if (emailToDepartmentSetMap.has(email?.toLowerCase())) {
      departmentSet = JSON.stringify(Array.from(emailToDepartmentSetMap.get(email.toLowerCase()).values()));
    }
    let uniqueUser = {
      email: user.email,
      full_name: user.name,
      last_access_at: lastAccess,
      last_access_date: (lastAccess / 86400) + 25569,
      departmentSet: departmentSet,
      user_id: Number(user.id),
      user_tier_id: Number(user.type.id),
      user_tier_name: userTierName,
      eventType: UNIQUE_USERS_DATA_TYPE_NAME
    };
    uniqueUsersArray.push(uniqueUser);
  };

  return uniqueUsersArray;
}


/**
 * Post a set of unique users to the Showback_UniqueUsers data type in NRDB.
 * @param {*} uniqueUsersArray an array of unique users.
 */
function postUniqueUsers(uniqueUsersArray) {
  // Chunk and post array
  chunkAndPostCustomEvents(uniqueUsersArray);
}


/**
 * Function to chunk the posting of custom events through the New Relic Event API.
 * @param {*} array an array of events to be posted in chunks.
 */
function chunkAndPostCustomEvents(array) {
  let chunkedArray = [];
  Array.from({
    length: Math.ceil(array.length / CHUNK_SIZE)
  }, (val, i) => {
    chunkedArray.push(array.slice(i * CHUNK_SIZE, i * CHUNK_SIZE + CHUNK_SIZE));
  });
  // Send to the Event API
  chunkedArray.forEach(chunk => {
    let body = JSON.stringify(chunk, null, 2);
    postCustomEvents(body);
  });
}


/**
 * Function to chunk the posting of dimensional metrics through the New Relic Metric API.
 * @param {*} array an array of data to be posted in chunks.
 */
 function chunkAndPostMetrics(array) {
  // Break out array into dimensional metrics
  let chunkedArray = [];
  Array.from({
    length: Math.ceil(array.length / CHUNK_SIZE)
  }, (val, i) => {
    chunkedArray.push(array.slice(i * CHUNK_SIZE, i * CHUNK_SIZE + CHUNK_SIZE));
  });
  // Send to the Event API
  chunkedArray.forEach(chunk => {
    const metricsPayload = [{
      "metrics": chunk
    }];
    let body = JSON.stringify(metricsPayload, null, 2);
    postMetrics(body);
  });
}


/**
 * List an organization's accounts.
 * 
 * @returns {Promise} a list of the accounts in the organization.
 */
async function getOrgAccounts() {
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query: `query
        {
          actor {
            organization {
              accountManagement {
                managedAccounts {
                  id
                  isCanceled
                  name
                  regionCode
                }
              }
            }
          }
        }
      `
    }),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    console.debug('getOrgAccounts() postWithRetries');
    let response = await postWithRetries(options);
    let responseBody = JSON.parse(response.body);
    if (responseBody.hasOwnProperty('errors')) {
      console.error(responseBody.errors);
    }
    let managedAccounts = responseBody.data.actor.organization.accountManagement.managedAccounts;
    return managedAccounts;
  } catch (error) {
    console.error('getOrgAccounts():', error);
  }
}


/**
 * Post a set of account users to the Showback_AccountUsers data type in NRDB.
 * @param {*} emailToUserAndGroupsMap a map of users (by email) to their user details and groups.
 * @param {*} groupIdToRolesMap a map of groups by id to their roles.
 * @param {*} accountIdToAccountMap a map of account ids to accounts.
 * @returns an array of account users. 
 */
function postAccountUsers(emailToUserAndGroupsMap, groupIdToRolesMap, accountIdToAccountMap) {
  let accountUsersArray = [];
  for (const [email, user] of emailToUserAndGroupsMap) {
    let lastAccess = new Date(user.lastActive).getTime();
    let userTierName;
    if (user.type.displayName == 'Full platform') {
      userTierName = 'FSO';
    } else if (user.type.displayName == 'Basic') {
      userTierName = 'Basic';
    } else {
      userTierName = 'Core';
    }
    if (!user.groups) {
      console.log('postAccountUsers(): User has no groups', JSON.stringify(user, null, 4));
      let accountUserObject = {
        account_id: null,
        account_name: null,
        email: user.email,
        full_name: user.name,
        group_id: null,
        group_name: null,
        last_access_at: lastAccess,
        last_access_date: (lastAccess / 86400) + 25569,
        user_id: Number(user.id),
        user_tier_id: Number(user.type.id),
        user_tier_name: userTierName,
        user_role: null,
        eventType: ACCOUNT_USERS_DATA_TYPE_NAME
      };
      accountUsersArray.push(accountUserObject);
      continue;
    }
    for (const group of user.groups.groups) {
      if (groupIdToRolesMap.get(group.id)) {
        for (const role of groupIdToRolesMap.get(group.id)) {
          let account = accountIdToAccountMap.get(role.accountId);
          if (account?.isCanceled) {
            continue;
          }
          let accountUserObject = {
            account_id: role.accountId,
            account_name: account?.name,
            // parent_account_id: activeAccountsMap.get(grant.grantedOn.name).parent_account_id,  // No longer available in V2
            email: user.email,
            full_name: user.name,
            group_id: group.id,
            group_name: group.displayName,
            last_access_at: lastAccess,
            last_access_date: (lastAccess / 86400) + 25569,
            user_id: Number(user.id),
            user_tier_id: Number(user.type.id),
            user_tier_name: userTierName,
            user_role: role.displayName,
            eventType: ACCOUNT_USERS_DATA_TYPE_NAME
          };
          accountUsersArray.push(accountUserObject);
        }
      } else {
        console.error('postAccountUsers(): Group does not exist in groupIdToRolesMap.get(group.id)', group);
      }
    }
  };

  // Chunk and post array
  chunkAndPostCustomEvents(accountUsersArray);
  return accountUsersArray;
}


/**
 * Build a map of users (by email) to their user details and groups.
 * @param {*} groupIdToGroupAndUsersMap a map of groups by id to their group and users.
 * @returns a map of users (by email) to their user details and groups.
 */
function buildEmailToUserAndGroupsMap(groupIdToGroupAndUsersMap) {
  let emailToUserAndGroupsMap = new Map();
  for (const [groupId, group] of groupIdToGroupAndUsersMap) {
    if (!group.users) continue;  // Groups may have zero users
    for (let user of group.users.users) {
      if (emailToUserAndGroupsMap.has(user.email)) {
        user = emailToUserAndGroupsMap.get(user.email);
        user.groups.groups.push({ displayName: group.displayName, id: group.id });
      } else {
        user.groups = {
          groups: [
            {
              displayName: group.displayName,
              id: group.id
            }
          ]
        };
      }
      if (user.email) {
        emailToUserAndGroupsMap.set(user.email, user);
      }
    }
  }
  return emailToUserAndGroupsMap;
}


/**
 * Enrich a map of users (by email) with additional user details.
 * @param {*} authDomainsArray an array of auth domains
 * @param {*} emailToUserAndGroupsMap a map of users (by email) to their user details and groups.
 * @returns an object containing: an enriched map of users (by email) to their user details and groups, and a consolidated map of users (by case insensitive email) to their user details and groups.
 */
async function enrichEmailToUserAndGroupsMap(authDomainsArray, emailToUserAndGroupsMap) {
  const body = {
    query: `
      query ($authDomainId: [ID!], $usersCursor: String) {
        actor {
          organization {
            userManagement {
              authenticationDomains(id: $authDomainId) {
                authenticationDomains {
                  users(cursor: $usersCursor) {
                    nextCursor
                    users {
                      email
                      id
                      lastActive
                      name
                      timeZone
                      type {
                        id
                        displayName
                      }
                    }
                  }
                  id
                  name
                }
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainId": null,
      "usersCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    let enrichedEmailToUserAndGroupsMap = new Map();
    let consolidatedEmailToUserAndGroupsMap = new Map();
    for (const authDomain of authDomainsArray) {
      body.variables.authDomainId = authDomain.id;
      options.body = JSON.stringify(body);
      console.log('enrichEmailToUserAndGroupsMap(): authDomain.id:', authDomain.id);
      let users = [];
      do {
        console.debug('enrichEmailToUserAndGroupsMap() postWithRetries, Auth Domain:' + authDomain.name);
        let response = await postWithRetries(options);
        console.log('enrichEmailToUserAndGroupsMap(): options:', options);
        let responseBody = JSON.parse(response.body);
        if (responseBody.hasOwnProperty('errors')) {
          console.error(responseBody.errors);
        }
        let usersArray = responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].users.users;
        users = users.concat(usersArray);
        body.variables.usersCursor = responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].users.nextCursor;
        options.body = JSON.stringify(body);
      } while (body.variables.usersCursor)
      // Enrich emailToUserAndGroupsMap with additional user data
      for (const user of users) {
        let originalUser = emailToUserAndGroupsMap.get(user.email);
        let enrichedUser = Object.assign(user, originalUser);  // Copy all enumerable own properties from originalUser to user
        if (user.email) {
          enrichedEmailToUserAndGroupsMap.set(user.email, enrichedUser);
        }

        // Consolidate users with multiple email cases (email address, user type, last active time, and groups)
        let caseInsensitiveEmail = user.email?.toLowerCase();
        if (consolidatedEmailToUserAndGroupsMap.has(caseInsensitiveEmail)) {  // A case insensitive email address already exists
          let consolidatedUser = consolidatedEmailToUserAndGroupsMap.get(caseInsensitiveEmail);
          // Consolidate to a case insensitive email address
          consolidatedUser.email = caseInsensitiveEmail;
          // Consolidate the user type
          if (consolidatedUser.type.displayName == 'Basic' && enrichedUser.type.displayName == 'Core') {
            consolidatedUser.type = enrichedUser.type;  // Update the type to Core
            consolidatedUser.id = enrichedUser.id;
            consolidatedUser.name = enrichedUser.name;
            consolidatedUser.timeZone = enrichedUser.timeZone;
          } else if ((consolidatedUser.type.displayName == 'Basic' || consolidatedUser.type.displayName == 'Core') && enrichedUser.type.displayName == 'Full platform') {
            consolidatedUser.type = enrichedUser.type;  // Update the user type to Full
            consolidatedUser.id = enrichedUser.id;
            consolidatedUser.name = enrichedUser.name;
            consolidatedUser.timeZone = enrichedUser.timeZone;
          }
          // Consolidate to the latest active time
          if (enrichedUser.lastActive) {
            if (consolidatedUser.lastActive) {
              // Set the latest of the two last active times
              let enrichedLastActiveMillis = new Date(enrichedUser.lastActive).getTime();
              let consolidatedLastActiveMillis = new Date(consolidatedUser.lastActive).getTime();
              if (enrichedLastActiveMillis >= consolidatedLastActiveMillis) consolidatedUser.lastActive = enrichedUser.lastActive;
            } else {  // Update to the enriched last active time
              consolidatedUser.lastActive = enrichedUser.lastActive;
            }
          }
          // Consolidate groups
          let consolidatedGroupsSet = consolidatedUser.groups && consolidatedUser.groups.groups ? new Set(consolidatedUser.groups.groups) : new Set();
          let enrichedGroupsSet = enrichedUser.groups && enrichedUser.groups.groups ? new Set(enrichedUser.groups.groups) : new Set();
          if (consolidatedUser.groups) {
            consolidatedUser.groups.groups = Array.from(new Set([...consolidatedGroupsSet, ...enrichedGroupsSet]));
          } else {
            consolidatedUser.groups = new Object();
            consolidatedUser.groups.groups = Array.from(new Set([...consolidatedGroupsSet, ...enrichedGroupsSet]));
          }
        } else {  // This email address has not been encountered yet
          if (caseInsensitiveEmail) {
            consolidatedEmailToUserAndGroupsMap.set(caseInsensitiveEmail, enrichedUser);
          } else {
            console.error('enrichEmailToUserAndGroupsMap(): user', user, 'does not have an email address!')
          }
        }
      }
    };
    console.log('enrichEmailToUserAndGroupsMap(): enrichedEmailToUserAndGroupsMap:', enrichedEmailToUserAndGroupsMap);
    console.log('enrichEmailToUserAndGroupsMap(): consolidatedEmailToUserAndGroupsMap:', consolidatedEmailToUserAndGroupsMap);
    return { enrichedEmailToUserAndGroupsMap, consolidatedEmailToUserAndGroupsMap };
  } catch (error) {
    console.error('enrichEmailToUserAndGroupsMap():', error);
  }
}


/**
 * Build a map of users (by email) to their accounts. 
 * @param {*} emailToUserAndGroupsMap a map of users (by email) to their user details and groups.
 * @param {*} groupIdToRolesMap a map of groups by id to their roles.
 * @param {*} accountIdToAccountMap a map of account ids to accounts.
 * @returns an object containing: a map of users (by email) to their accounts, and a consolidated map of users (by case insensitive email) to their accounts.
 */
function buildEmailToAccountsMap(emailToUserAndGroupsMap, groupIdToRolesMap, accountIdToAccountMap) {
  let emailToAccountSetMap = new Map();
  let consolidatedEmailToAccountSetMap = new Map();
  let ignoredGroups = [ %{~ for index_group, group in tf_showback_ignore_groups ~}%{ if index_group != 0 }, %{ endif }"${group}"%{~ endfor ~} ];
  for (const [email, user] of emailToUserAndGroupsMap) {
    let accountSet = new Set();
    if (!user.groups) {
      console.error('buildEmailToAccountsMap(): User has no groups (check email case)', JSON.stringify(user, null, 4));
    } else {
      for (const group of user.groups.groups) {
        // Check whether to ignore the group, continue if it is to be ignored
        if (ignoredGroups.includes(group.displayName)) {
          continue;
        }
        if (groupIdToRolesMap.has(group.id)) {
          let roles = groupIdToRolesMap.get(group.id);
          for (const role of roles) {
            if (role.accountId) {
              let account = accountIdToAccountMap.get(role.accountId);
              if (account && !account.isCanceled) {
                accountSet.add(account);
              }
            } else if (role.organizationId) {
              console.log('buildEmailToAccountsMap(): Role associated with an organization, not account', role);
            } else {
              console.error('buildEmailToAccountsMap(): Role not associated with either an account or organization', role);
            }
          }
        } else {
          console.error('buildEmailToAccountsMap(): Group does not exist in groupIdToRolesMap.get(group.id)', group);
        }
      }
    }
    if (email) {
      emailToAccountSetMap.set(email, accountSet);
    }
    let caseInsensitiveEmail = email?.toLowerCase();
    if (consolidatedEmailToAccountSetMap.has(caseInsensitiveEmail)) {  // A case insensitive email address already exists
      let existingAccountSet = consolidatedEmailToAccountSetMap.get(caseInsensitiveEmail);
      consolidatedEmailToAccountSetMap.set(caseInsensitiveEmail, new Set([...accountSet, ...existingAccountSet]));
    } else {
      if (caseInsensitiveEmail) {
        consolidatedEmailToAccountSetMap.set(caseInsensitiveEmail, accountSet);
      } else {
        console.error("buildEmailToAccountsMap(): user has no email address!", user);
      }
    }
  }
  return { emailToAccountSetMap: emailToAccountSetMap, consolidatedEmailToAccountSetMap: consolidatedEmailToAccountSetMap };
}


/**
 * Build a map of accounts, by id, to their users. 
 * @param {*} emailToUserAndGroupsMap a map of users (by email) to their user details and groups.
 * @param {*} groupIdToRolesMap a map of groups by id to their roles.
 * @returns a map of accounts, by id, to their users.
 */
 function buildAccountToUsersMap(emailToUserAndGroupsMap, groupIdToRolesMap) {
  let accountIdToUsersMap = new Map();
  let ignoredGroups = [ %{~ for index_group, group in tf_showback_ignore_groups ~}%{ if index_group != 0 }, %{ endif }"${group}"%{~ endfor ~} ];
  for (const [email, user] of emailToUserAndGroupsMap) {
    if (!user.groups) {
      console.log('buildEmailToAccountsMap(): User has no groups', JSON.stringify(user, null, 4));
      continue;
    }
    for (const group of user.groups.groups) {
      // Check whether to ignore the group, continue if it is to be ignored
      if (ignoredGroups.includes(group.displayName)) {
        continue;
      }
      if (groupIdToRolesMap.has(group.id)) {
        let roles = groupIdToRolesMap.get(group.id);
        for (const role of roles) {
          if (role.accountId) {
            if (accountIdToUsersMap.has(role.accountId)) {
              accountIdToUsersMap.get(role.accountId).add(user);
            } else {
              accountIdToUsersMap.set(role.accountId, new Set([user]));
            }
          } else if (role.organizationId) {
            console.log('buildAccountToUsersMap(): Role associated with an organization, not account', role);
          } else {
            console.error('buildAccountToUsersMap(): Role not associated with either an account or organization', role);
          }
        }
      } else {
        console.error('buildAccountToUsersMap(): Group does not exist in groupIdToRolesMap.get(group.id)', group);
      }
    }
  }
  return accountIdToUsersMap;
}


/**
 * Build a map of departments to their user type counts.
 * @param {*} consolidatedEmailToAccountSetMap a (case insensitive) map of users (by email) to their accounts.
 * @param {*} consolidatedEmailToUserAndGroupsMap a (case insensitive) map of users (by email) to their user details and groups.
 * @param {*} accountIdToAccountMap a map of account ids to accounts.
 * @returns a map of departments to their user type counts, and a map of user to departments.
 */
function buildDepartmentToUserTypeCountsMap(consolidatedEmailToAccountSetMap, consolidatedEmailToUserAndGroupsMap, accountIdToAccountMap) {
  let departmentToUserTypeCountsMap = new Map();
  let emailToDepartmentSetMap = new Map();
  let ignoreNewRelicUsers = ${tf_showback_ignore_newrelic_users};
  for (const [email, accountSet] of consolidatedEmailToAccountSetMap) {
    let departmentSet = new Set();
    let tierToDeptSetMap = new Map();
    for (const account of accountSet) {
      if (account?.isCanceled) continue;
      let map = getDepartmentMapping(account);
      for (const [tier, deptSet] of map) {
        let existingDeptSet = tierToDeptSetMap.get(tier);
        if (existingDeptSet) {
          tierToDeptSetMap.set(tier, new Set([...existingDeptSet, ...deptSet]))
        } else {
          tierToDeptSetMap.set(tier, deptSet);
    }
      }
    }
    for (const [tier, deptSet] of tierToDeptSetMap) {
      departmentSet = new Set([...departmentSet, ...deptSet]);
      if (deptSet.size == 1 && deptSet.has(DEPARTMENT_UNASSIGNED)) {
        console.error("buildDepartmentToUserTypeCountsMap: Department undefined for user:", email, "and tier:", tier);
      }
    }
    if (email) {
      emailToDepartmentSetMap.set(email, departmentSet);
    }

    // Handle users with no department
    if (departmentSet.size == 0) {
      let proportion = 1;
      console.error("buildDepartmentToUserTypeCountsMap: Department undefined for user:", email);
      let user = consolidatedEmailToUserAndGroupsMap.get(email);
      if (user) {
        let userType = user.type;
        user.departmentSet = new Set([DEPARTMENT_UNASSIGNED]);
        if (departmentToUserTypeCountsMap.has(DEPARTMENT_UNASSIGNED)) {  // Update the map entry with the proportion for this user
          let userTypeCountsObject = departmentToUserTypeCountsMap.get(DEPARTMENT_UNASSIGNED);
          if (userType.displayName === 'Full platform') {
            userTypeCountsObject.full_platform += proportion;
          } else if (userType.displayName === 'Core') {
            userTypeCountsObject.core += proportion;
          } else if (userType.displayName === 'Basic') {
            userTypeCountsObject.basic += proportion;
          } else {
            console.error('buildDepartmentToUserTypeCountsMap(): Unknown user type:', userType)
          }
        } else {  // Initialize the user type counts for the department, and create the map entry
          let userTypeCountsObject = {
            full_platform: userType.displayName === 'Full platform' ? proportion : 0,
            core: userType.displayName === 'Core' ? proportion : 0,
            basic: userType.displayName === 'Basic' ? proportion : 0
          };
          departmentToUserTypeCountsMap.set(DEPARTMENT_UNASSIGNED, userTypeCountsObject);
        }
      }
    }

    // Skip / ignore new relic users for showback reporting by department
    if (ignoreNewRelicUsers) {
      if ((/@newrelic.com/).test(email)) {
        console.debug("Ignoring user for showback reporting by department:", email);
        continue;
      }
    }

    for (const [tier, deptSet] of tierToDeptSetMap) {
      // Apportion the user to each department they are a member of proportionally,
      // e.g. if the user is a full_platform user and in two departments,
      // add 0.5 of a full_platform user to each department.
      let proportion = 1/deptSet.size;
      if (proportion < 1) {
        // The user is a member of accounts under two or more different departments, so split equally
        console.log("buildDepartmentToUserTypeCountsMap():", email, "is in multiple departments:", departmentSet, "apportioning equally across each department");
      }

      // Initialize, or update, an existing department's userCount
      let user = consolidatedEmailToUserAndGroupsMap.get(email);
      if (user) {
        let userType = user.type;
          user.departmentSet = deptSet;
          for (const department of deptSet) {
          if (departmentToUserTypeCountsMap.has(department)) {  // Update the map entry with the proportion for this user
            let userTypeCountsObject = departmentToUserTypeCountsMap.get(department);
            if (userType.displayName === 'Full platform') {
              userTypeCountsObject.full_platform += proportion;
            } else if (userType.displayName === 'Core') {
              userTypeCountsObject.core += proportion;
            } else if (userType.displayName === 'Basic') {
              userTypeCountsObject.basic += proportion;
            } else {
              console.error('buildDepartmentToUserTypeCountsMap(): Unknown user type:', userType)
            }
          } else {  // Initialize the user type counts for the department, and create the map entry
            let userTypeCountsObject = {
              full_platform: userType.displayName === 'Full platform' ? proportion : 0,
              core: userType.displayName === 'Core' ? proportion : 0,
              basic: userType.displayName === 'Basic' ? proportion : 0
            };
            departmentToUserTypeCountsMap.set(department, userTypeCountsObject);
          }
        }
      }
    }
  }

  return { departmentToUserTypeCountsMap, emailToDepartmentSetMap };
}


/**
 * Post a set of departments to NRDB.
 * @param {*} departmentToUserTypeCountsMap a map of departments to their user type counts.
 * @param {*} departmentToTierMap a map of departments to their tier.
 * @param {*} timestamp the metric timestamp.
 * @returns an array of departments and their counts of full platform, core and basic users.
 */
function postDepartmentShowback(departmentToUserTypeCountsMap, departmentToTierMap, timestamp) {
  let departmentArray = Array.from(departmentToUserTypeCountsMap, ([department, userTypesCountObject]) => ({
    [DEPARTMENT_ATTRIBUTE_NAME]: department,
    [FULL_USER_COUNT_ATTRIBUTE_NAME]: userTypesCountObject.full_platform,
    [CORE_USER_COUNT_ATTRIBUTE_NAME]: userTypesCountObject.core,
    [BASIC_USER_COUNT_ATTRIBUTE_NAME]: userTypesCountObject.basic,
    [TOTAL_USER_COUNT_ATTRIBUTE_NAME]: userTypesCountObject.basic + userTypesCountObject.core + userTypesCountObject.full_platform
  }));

  /*
   * Dimensional metrics
   */
  let metrics = new Array();
  let tierToAggregateUserCountObjectMap = new Map();
  // By department metrics
  for (const [department, userTypeCountsObject] of departmentToUserTypeCountsMap) {
    let tier = departmentToTierMap.get(department);
    tier ??= DEFAULT_DEPT_TIER;  // Nullish coalescing assignment, to assign the default tier (1)
    let aggregateUserCountObject;
    if (tierToAggregateUserCountObjectMap.has(tier)) {
      aggregateUserCountObject = tierToAggregateUserCountObjectMap.get(tier);
    } else {
      aggregateUserCountObject = {
        basic: 0,
        core: 0,
        full: 0,
        total: 0
      }
    }
    let basicUserDeptMetric = getDimensionalMetricObject("showback.department.basicuser.count", "gauge", userTypeCountsObject.basic, timestamp, { "department": department, "tier": tier });
    metrics.push(basicUserDeptMetric);
    aggregateUserCountObject.basic += userTypeCountsObject.basic;

    let coreUserDeptMetric = getDimensionalMetricObject("showback.department.coreuser.count", "gauge", userTypeCountsObject.core, timestamp, { "department": department, "tier": tier });
    metrics.push(coreUserDeptMetric);
    aggregateUserCountObject.core += userTypeCountsObject.core;

    let fullUserDeptMetric = getDimensionalMetricObject("showback.department.fulluser.count", "gauge", userTypeCountsObject.full_platform, timestamp, { "department": department, "tier": tier });
    metrics.push(fullUserDeptMetric);
    aggregateUserCountObject.full += userTypeCountsObject.full_platform;

    let totalUserDeptCount = userTypeCountsObject.basic + userTypeCountsObject.core + userTypeCountsObject.full_platform;
    let totalUserDeptMetric = getDimensionalMetricObject("showback.department.totaluser.count", "gauge", totalUserDeptCount, timestamp, { "department": department, "tier": tier });
    metrics.push(totalUserDeptMetric);
    aggregateUserCountObject.total += totalUserDeptCount;
    tierToAggregateUserCountObjectMap.set(tier, aggregateUserCountObject);
  }
  // Aggregates metrics
  for (const [tier, aggregateUserCountObject] of tierToAggregateUserCountObjectMap) {
    if (tier > 1) {
      let userTypeCountsObject = departmentToUserTypeCountsMap.get(DEPARTMENT_UNASSIGNED);
      aggregateUserCountObject.basic += userTypeCountsObject.basic;
      aggregateUserCountObject.core += userTypeCountsObject.core;
      aggregateUserCountObject.full += userTypeCountsObject.full_platform;
      aggregateUserCountObject.total += userTypeCountsObject.basic + userTypeCountsObject.core + userTypeCountsObject.full_platform;
    }
    let totalBasicUserMetric = getDimensionalMetricObject("showback.organization.basicuser.count", "gauge", aggregateUserCountObject.basic, timestamp, { "tier": tier });
    metrics.push(totalBasicUserMetric);
    let totalCoreUserMetric = getDimensionalMetricObject("showback.organization.coreuser.count", "gauge", aggregateUserCountObject.core, timestamp, { "tier": tier });
    metrics.push(totalCoreUserMetric);
    let totalFullUserMetric = getDimensionalMetricObject("showback.organization.fulluser.count", "gauge", aggregateUserCountObject.full, timestamp, { "tier": tier });
    metrics.push(totalFullUserMetric);
    let totalUserMetric = getDimensionalMetricObject("showback.organization.totaluser.count", "gauge", aggregateUserCountObject.total, timestamp, { "tier": tier });
    metrics.push(totalUserMetric);
  }
  chunkAndPostMetrics(metrics);
  
  return departmentArray;
}


/**
 * Get a dimensional metric object for inclusion in a call to the New Relic Metrics API endpoint.
 * @param {*} name the metric name.
 * @param {*} type the metric type, e.g. gauge.
 * @param {*} value the metric value.
 * @param {*} timestamp the metric timestamp.
 * @param {*} attributes an object containing the metric attributes.
 * @returns a dimensional metric object.
 */
function getDimensionalMetricObject(name, type, value, timestamp, attributes) {
  return {
    "name": name,
    "type": type,
    "value": value,
    "timestamp": timestamp,
    "attributes": attributes
  };
}


/**
 * Post a set of accounts to NRDB, along with assigned user counts by user type.
 * @param {*} accountToUsersMap a map of accounts to their users.
 * @param {*} accountIdToAccountMap a map of account ids to account names.
 *  * @param {*} timestamp the metric timestamp.
 * @returns an array of accounts.
 */
function postAccounts(accountToUsersMap, accountIdToAccountMap, timestamp) {
  let accountArray = [];
  for (const [accountId, users] of accountToUsersMap) {
    let basicUserCount = 0, coreUserCount = 0, fullUserCount = 0;
    for (const user of users) {
      let userType = user.type;
      if (userType.displayName === 'Full platform') {
        fullUserCount++;
      } else if (userType.displayName === 'Core') {
        coreUserCount++;
      } else if (userType.displayName === 'Basic') {
        basicUserCount++;
      } else {
        console.error('postAccounts(): Unknown user type:', userType)
      }
    }
    let account = accountIdToAccountMap.get(accountId);
    if (account && !account.isCanceled) {
      accountArray.push(
        {
          "account_id": accountId,
          "account_name": account?.name,
          [BASIC_USER_COUNT_ATTRIBUTE_NAME]: basicUserCount,
          [CORE_USER_COUNT_ATTRIBUTE_NAME]: coreUserCount,
          [FULL_USER_COUNT_ATTRIBUTE_NAME]: fullUserCount,
          [TOTAL_USER_COUNT_ATTRIBUTE_NAME]: basicUserCount + coreUserCount + fullUserCount
        }
      )
    }
  }

  /*
   * Dimensional metrics
   */
  let metrics = new Array();
  // By account metrics
  for (const account of accountArray) {
    let basicUserAccountMetric = getDimensionalMetricObject("showback.account.basicuser.count", "gauge", account[BASIC_USER_COUNT_ATTRIBUTE_NAME], timestamp, { "account": account.account_name, "account_id": account.account_id });
    metrics.push(basicUserAccountMetric);

    let coreUserAccountMetric = getDimensionalMetricObject("showback.account.coreuser.count", "gauge", account[CORE_USER_COUNT_ATTRIBUTE_NAME], timestamp,  { "account": account.account_name, "account_id": account.account_id });
    metrics.push(coreUserAccountMetric);

    let fullUserAccountMetric = getDimensionalMetricObject("showback.account.fulluser.count", "gauge", account[FULL_USER_COUNT_ATTRIBUTE_NAME], timestamp,  { "account": account.account_name, "account_id": account.account_id });
    metrics.push(fullUserAccountMetric);

    let totalUserAccountCount = account[BASIC_USER_COUNT_ATTRIBUTE_NAME] + account[CORE_USER_COUNT_ATTRIBUTE_NAME] + account[FULL_USER_COUNT_ATTRIBUTE_NAME];
    let totalUserAccountMetric = getDimensionalMetricObject("showback.account.totaluser.count", "gauge", totalUserAccountCount, timestamp,  { "account": account.account_name, "account_id": account.account_id });
    metrics.push(totalUserAccountMetric);
  }
  chunkAndPostMetrics(metrics);

  return accountArray;
}


/**
 * Function to post custom events through the New Relic Event API.
 * 
 * @param {*} accountId the reporting account id.
 * @param {*} body a JSON object with events in the New Relic Event API format.
 * @returns {Promise<request.Response>} the response from the Event API endpoint.
 */
async function postCustomEvents(body) {
  let options = {
    url: eventApiEndpoint + '/v1/accounts/' + SHOWBACK_REPORTING_INSERT_ACCOUNT_ID + '/events',
    body: body,
    headers: {
      'Api-Key': $secure.SHOWBACK_INSERT_LICENSE_API_KEY,
      'Content-Type': 'application/json'
    },
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  }
  try {
    console.debug('postCustomEvents() postWithRetries');
    return await postWithRetries(options);
  } catch (e) {
    console.error('postCustomEvents():', e);
  }
}


/**
 * Function to post metrics through the New Relic Metrics API.
 * 
 * @param {*} accountId the reporting account id.
 * @param {*} body a JSON object with metrics in the New Relic Metric API format.
 * @returns {Promise<request.Response>} the response from the Metric API endpoint.
 */
 async function postMetrics(body) {
  let options = {
    url: metricApiEndpoint,
    body: body,
    headers: {
      'Api-Key': $secure.SHOWBACK_INSERT_LICENSE_API_KEY,
      'Content-Type': 'application/json'
    },
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  }
  try {
    console.debug('postMetrics() postWithRetries');
    return await postWithRetries(options);
  } catch (e) {
    console.error('postMetrics():', e);
  }
}


/**
 * Get a map of auth domains to their groups.
 * @param {*} authDomainsArray an array of auth domains.
 * @returns a map of auth domains to their groups.
 */
async function getAuthDomainToGroupsMap(authDomainsArray) {
  const body = {
    query: `
      query ($authDomainId: [ID!], $groupsCursor: String) {
        actor {
          organization {
            authorizationManagement {
              authenticationDomains(id: $authDomainId) {
                authenticationDomains {
                  groups(cursor: $groupsCursor) {
                    groups {
                      displayName
                      id
                    }
                    nextCursor
                  }
                  id
                  name
                }
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainId": null,
      "groupsCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    let authDomainToGroupsMap = new Map();
    for (const authDomain of authDomainsArray) {
      let groups = [];
      do {
        body.variables.authDomainId = authDomain.id;
        options.body = JSON.stringify(body);
        console.debug('getAuthDomainToGroupsMap() postWithRetries', authDomain.name);
        let response = await postWithRetries(options);
        let responseBody = JSON.parse(response.body);
        if (responseBody.hasOwnProperty('errors')) {
          console.error(responseBody.errors);
        }
        groups = groups.concat(responseBody.data.actor.organization.authorizationManagement.authenticationDomains.authenticationDomains[0].groups.groups);
        body.variables.groupsCursor = responseBody.data.actor.organization.authorizationManagement.authenticationDomains.authenticationDomains[0].groups.nextCursor;
        options.body = JSON.stringify(body);
      } while (body.variables.groupsCursor)
      // Set the groups for the auth domain
      authDomainToGroupsMap.set(authDomain.id, groups);
    };
    return authDomainToGroupsMap;
  } catch (error) {
    console.error('getAuthDomainToGroupsMap():', error);
  }
}


/**
 * Get an array of auth domains for the organization.
 * @returns an array of auth domains.
 */
async function getAuthDomainsArray() {
  const body = {
    query: `
      query ($authDomainCursor: String) {
        actor {
          organization {
            authorizationManagement {
              authenticationDomains(cursor: $authDomainCursor) {
                authenticationDomains {
                  id
                  name
                }
                nextCursor
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    let authDomains = [];
    do {
      console.debug('getAuthDomainsArray()postWithRetries');
      let response = await postWithRetries(options);
      let responseBody = JSON.parse(response.body);
      if (responseBody.hasOwnProperty('errors')) {
        console.error(responseBody.errors);
      }
      authDomains = authDomains.concat(responseBody.data.actor.organization.authorizationManagement.authenticationDomains.authenticationDomains);
      body.variables.authDomainCursor = responseBody.data.actor.organization.authorizationManagement.authenticationDomains.nextCursor;
      options.body = JSON.stringify(body);
    } while (body.variables.authDomainCursor)
    return authDomains;
  } catch (error) {
    console.error('getAuthDomainsArray():', error);
  }
}


/**
 * Delay (sleep) by a number of milliseconds.
 * @param {*} milliseconds number of milliseconds to wait for.
 * @returns 
 */
function delay(milliseconds) {
  return new Promise(resolve => setTimeout(resolve, milliseconds));
}


/**
 * Get a map of groups by id to their roles.
 * @param {*} authDomainsToGroupsMap a map of auth domains to their groups.
 * @returns a map of groups by id to their roles.
 */
async function getGroupIdToRolesMap(authDomainsToGroupsMap) {
  try {
    // I'm fairly certain that group/role/account is a triplet, that is a group only has one role per account, but the API suggests that might change
    let groupIdToRolesMap = new Map();
    for (const authDomain of authDomainsToGroupsMap.keys()) {
      let groupsArray = authDomainsToGroupsMap.get(authDomain);

      // Chunk array before querying to avoid hitting the GraphQL API request limit
      let chunkedGroupsArray = [];
      Array.from({length: Math.ceil(groupsArray.length / GQL_API_CHUNK_SIZE)}, (val, i) => {
        chunkedGroupsArray.push(groupsArray.slice(i * GQL_API_CHUNK_SIZE, i * GQL_API_CHUNK_SIZE + GQL_API_CHUNK_SIZE))
      });

      // Run the chunked queries in parallel
      for (const chunkedGroups of chunkedGroupsArray) {  // Blocking
        let promises = [];
        for (const group of chunkedGroups) {
          promises.push(getGroupIdAndRolesObjectWithRetries(authDomain, group));
        };
        // Await all promises  
        let groupIdAndRolesArray = await Promise.all(promises);
        for (const groupIdAndRolesObject of groupIdAndRolesArray) {
          groupIdToRolesMap.set(groupIdAndRolesObject.groupId, groupIdAndRolesObject.roles);
        }
        // Wait 0.05 seconds before issuing queries for the next chunk of groups, to avoid hitting the NerdGraph query limit
        await delay(50);
      }
    };
    return groupIdToRolesMap;
  } catch (error) {
    console.error('getGroupIdToRolesMap():', error);
  }
}


/**
 * Get an object relating a group id to its roles. A wrapper function that retries if the getGroupIdAndRolesObject() function errors.
 * @param {*} authDomain authentication domain for the supplied group.
 * @param {*} group group for which roles are to be retrieved.
 * @returns an object relating a group id to its roles { groupId: group.id, roles: roles}.
 */
async function getGroupIdAndRolesObjectWithRetries(authDomain, group) {
    let success = false;
    let groupIdAndRolesObject;
    let retries = 0;
    let currentError;
    do {
      try {
        groupIdAndRolesObject = await getGroupIdAndRolesObject(authDomain, group);
        success = true;
      } catch (error) {
        console.error("getGroupIdAndRolesObjectWithRetries(): An error occurred:", error);
        console.error("getGroupIdAndRolesObjectWithRetries(): retry count:", retries);
        currentError = error;
        retries++;
      }
    } while (!success && retries <= MAX_RETRIES);
    if (success) {
      return groupIdAndRolesObject;
    } else {
      console.error("getGroupIdAndRolesObjectWithRetries(): max retries exceeded:", MAX_RETRIES);
      throw currentError;
    }
}


/**
 * Get an object relating a group id to its roles.
 * @param {*} authDomain authentication domain for the supplied group.
 * @param {*} group group for which roles are to be retrieved.
 * @returns an object relating a group id to its roles { groupId: group.id, roles: roles}.
 */
async function getGroupIdAndRolesObject(authDomain, group) {
  const body = {
    query: `
      query ($authDomainId: [ID!], $groupId: [ID!], $rolesCursor: String) {
        actor {
          organization {
            authorizationManagement {
              authenticationDomains(id: $authDomainId) {
                authenticationDomains {
                  groups(id: $groupId) {
                    groups {
                      roles(cursor: $rolesCursor) {
                        roles {
                          accountId
                          type
                          roleId
                          organizationId
                          name
                          id
                          displayName
                        }
                        nextCursor
                      }
                      displayName
                      id
                    }
                  }
                }
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainId": null,
      "groupId": null,
      "rolesCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  return new Promise(async (resolve, reject) => {
    try {
      let roles = [];
      body.variables.authDomainId = authDomain;
      body.variables.groupId = group.id;
      options.body = JSON.stringify(body);
      let errorMessage = null;
      do {
        console.debug('getGroupIdAndRolesObject() postWithRetries', authDomain, group.displayName, body.variables.rolesCursor);
        let response = await postWithRetries(options);
        let responseBody = JSON.parse(response.body);
        if (responseBody.hasOwnProperty('errors')) {
          errorMessage = responseBody.errors; 
          console.error("getGroupIdAndRolesObject(): Errors present in response.body");
          break;
        }
        roles = roles.concat(responseBody.data.actor.organization.authorizationManagement.authenticationDomains.authenticationDomains[0].groups.groups[0].roles.roles);
        body.variables.rolesCursor = responseBody.data.actor.organization.authorizationManagement.authenticationDomains.authenticationDomains[0].groups.groups[0].roles.nextCursor;
        options.body = JSON.stringify(body);
      } while (body.variables.rolesCursor)
      if (errorMessage) {
        console.error('getGroupIdAndRolesObject():', errorMessage, authDomain, group.displayName);
        reject(errorMessage);
      } else {
        let hasAccount = false;
        for (const role of roles) {
          if (role.accountId) {
            hasAccount = true;
            break;
          }
        }
        if (!hasAccount) {
          console.error('getGroupIdAndRolesObject(): group has no accounts', group);
        }
        resolve({ groupId: group.id, roles: roles});
      }
    } catch (error) {
      console.error('getGroupIdAndRolesObject():', error, authDomain, group.displayName);
      reject(error);
    }
  })
}


/**
 * Get a map of groups by id to their group and users.
 * @param {*} authDomainsArray an array of auth domains
 * @returns a map of groups by id to their group and users.
 */
async function getGroupIdToGroupAndUsersMap(authDomainsArray) {
  const body = {
    query: `
      query ($authDomainId: [ID!], $groupsCursor: String) {
        actor {
          organization {
            userManagement {
              authenticationDomains(id: $authDomainId) {
                authenticationDomains {
                  groups(cursor: $groupsCursor) {
                    groups {
                      id
                      users {
                        users {
                          id
                          email
                          name
                          timeZone
                        }
                        nextCursor
                      }
                      displayName
                    }
                    nextCursor
                  }
                }
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainId": null,
      "groupsCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    let groupIdToGroupAndUsersMap = new Map();
    for (const authDomain of authDomainsArray) {
      body.variables.authDomainId = authDomain.id;
      options.body = JSON.stringify(body);
      console.log('getGroupIdToGroupAndUsersMap(): authDomain.id:', authDomain.id);
      let groups = [];
      do {
        console.debug('getGroupIdToGroupAndUsersMap() postWithRetries, Auth Domain:' + authDomain.name);
        let response = await postWithRetries(options);
        console.log('getGroupIdToGroupAndUsersMap(): options:', options);
        let responseBody = JSON.parse(response.body);
        if (responseBody.hasOwnProperty('errors')) {
          console.error(responseBody.errors);
        }
        let groupsArray = responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].groups.groups;
        groups = groups.concat(groupsArray);
        body.variables.groupsCursor = responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].groups.nextCursor;
        options.body = JSON.stringify(body);
        // Filter groups with user pagination
        const groupsWithNextCursorUser = groups.filter(group => {
          return group.users ? group.users.nextCursor : null;  // Groups may have zero users
        })
        for (const group of groupsWithNextCursorUser) { // Ghastly nested pagination in the GraphQL! :O
          let users = group.users.users;
          if (group.users.nextCursor) {
            users = await getGroupUsersByCursor(authDomain.id, group);
          }
          group.users.users = users;
        }
      } while (body.variables.groupsCursor)
      for (const group of groups) {
        groupIdToGroupAndUsersMap.set(group.id, group);
      }
      console.log('getGroupIdToGroupAndUsersMap(): groupIdToGroupAndUsersMap:', groupIdToGroupAndUsersMap);
    };
    return groupIdToGroupAndUsersMap;
  } catch (error) {
    console.error('getGroupIdToGroupAndUsersMap():', error);
  }
}


/**
 * Get group users for the supplied auth domain and group.
 * @param {*} authDomainId the auth domain id.
 * @param {*} group the group.
 * @returns group users for the supplied auth domain and group.
 */
async function getGroupUsersByCursor(authDomainId, group) {
  const body = {
    query: `
      query ($authDomainId: [ID!], $groupId: [ID!], $usersCursor: String) {
        actor {
          organization {
            userManagement {
              authenticationDomains(id: $authDomainId) {
                authenticationDomains {
                  groups(id: $groupId) {
                    groups {
                      users (cursor: $usersCursor) {
                        users {
                          id
                          email
                          name
                          timeZone
                        }
                        nextCursor
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    `,
    variables: {
      "authDomainId": null,
      "groupId": null,
      "usersCursor": null
    }
  }
  const options = {
    url: nerdGraphEndpoint,
    headers: {
      'API-key': $secure.SHOWBACK_QUERY_USER_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
    retry: { // By default, Got does not retry on POST
      limit: MAX_RETRIES,
      methods: ['POST']
    }
  };

  try {
    let users = group.users.users;
    body.variables.authDomainId = authDomainId;
    body.variables.groupId = group.id;
    body.variables.usersCursor = group.users.nextCursor;
    options.body = JSON.stringify(body);
    do {
      console.debug('getGroupUsersByCursor() postWithRetries for Auth Domain Id:' + authDomainId + ', and group: ' + group.displayName);  //
      let response = await postWithRetries(options);
      let responseBody = JSON.parse(response.body);
      if (responseBody.hasOwnProperty('errors')) {
        console.error(responseBody.errors);
      }
      users = users.concat(responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].groups.groups[0].users.users);
      body.variables.usersCursor = responseBody.data.actor.organization.userManagement.authenticationDomains.authenticationDomains[0].groups.groups[0].users.nextCursor;
      options.body = JSON.stringify(body);
      console.debug('getGroupUsersByCursor() postWithRetries for Auth Domain Id: ' + authDomainId + ', and group: ' + group.displayName + ', and usersCursor: ' + body.variables.usersCursor);
    } while (body.variables.usersCursor)
    return users;
  } catch (error) {
    console.error('getGroupUsersByCursor():', error)
  }
}


/**
 * Wrap $http.post with a configurable number of retries.
 * @param {*} options the post options.
 * @returns the response.
 */
async function postWithRetries(options) {
  let success = false;
  let response;
  let retries = 0;
  let currentError;
  do {
    try {
      response = await $http.post(options);
      let responseBody = JSON.parse(response.body);
      if (responseBody.hasOwnProperty('errors')) {
        console.error(responseBody.errors);
        console.error("postWithRetries(): An error occurred:", responseBody.errors);
        console.error("postWithRetries(): retry count:", retries);
        currentError = responseBody.errors;
        retries++;
      } else {
        success = true;
      }
    } catch (error) {
      console.error("postWithRetries(): An error occurred:", error);
      console.error("postWithRetries(): retry count:", retries);
      currentError = error;
      retries++;
    }
  } while (!success && retries <= MAX_RETRIES);
  if (success) {
    return response;
  } else {
    console.error("postWithRetries(): max retries exceeded:", MAX_RETRIES);
    throw currentError;
  }
}


/**
 * The scripts main function and starting point.
 */
async function main() {
  let response = await processShowback();

  console.log('main(): Script execution completed');
}


// Let's get this party started
main();